---
outline: deep
---

# ECMAScript 13 學習筆記

> 參考學習資源：[阮一峰 ECMAScript 6 (ES6) 標準入門教程](https://es6.ruanyifeng.com/)

## 類別的新特性

### 實體屬性的新寫法

ES2022 為類別的實體屬性，又規定了一種新寫法。實體屬性現在除了可以定義在 `constructor()` 方法裡面的 `this`上面，也可以定義在類別內部的最頂層。

```js
class Person {
  state = { // [!code ++]
    a: 1, // [!code ++]
    b: 2, // [!code ++]
  }; // [!code ++]

  constructor(name, age) {
    this.name = name;
    this.age = age;
    this.state = { // [!code --]
      a: 1, // [!code --]
      b: 2, // [!code --]
    }; // [!code --]
  }
}
const obj = new Person('sheep', 25);
```

### 私有屬性和方法

ES2022 正式為 class 新增了私有屬性，方法是在屬性名之前使用 `#` 表示，這種寫法不僅可以寫私有屬性，還可以用來寫私有方法。

```js
class Cache {
  static #count = 0;

  static getCount() {
    return this.#count;
  }

  #obj = {};

  get(key) {
    return this.#obj[key];
  }
  set(key, value) {
    this.#obj[key] = value;
  }
}
const cache = new Cache();
cache.set('name', 'sheep');
console.log(Cache.getCount());
```

![](https://i.imgur.com/ugeWDiX.png)

> 上面程式碼中，`#obj` 就是私有屬性，只能在 class 的內部使用（`this.#obj`）。如果在 class 的外部使用，就會報錯。


### 靜態程式碼區塊

> ES2022 引入了靜態區塊（static block），它允許在 class 中透過 `static` 關鍵字定義一系列靜態程式碼區塊，這些程式碼只會在 class 被創造的時候**執行一次**。

一個 class 可以定義任意多個靜態區塊，這些程式碼區塊會和穿插在它們之間的靜態成員變數一起按照定義的順序在 class 初始化的時候執行一次。我們還可以使用 `super` 關鍵字來存取父類別的屬性。

```js
class Cache {
  static obj = new Map();

  static {
    this.obj.set('name', 'sheep');
    this.obj.set('age', 18);
  }

  static {
    console.log(this.obj);
  }
}
```

### `in` 運算子

使用 `in` 可以判斷某個物件是否擁有某個私有屬性。

```js
class Cache {
  #obj = {};

  get(key) {
    return this.#obj[key];
  }
  set(key, value) {
    this.#obj[key] = value;
  }

  #privateMethod() {}

  hasObj() {
    return #obj in this;
  }
}

const store = new Cache();
console.log(store.hasObj()); // true
```

## Top-level `await`

> 頂層 `await` 只能用在 ES 模組，不能用在 CommonJS 模組。這是因為 CommonJS 模組的 `require()` 是同步載入，如果有頂層 `await`，就沒辦法處理載入了。

早期的語法規定是，`await` 指令只能出現在 async 函式內部，否則都會報錯。而從 ES2022 開始，允許在模組的頂層獨立使用 `await` 指令。

```js
function ajax() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('data-111');
    }, 2000);
  });
}

const data = await ajax();

export default {
  name: 'moduleA',
  data, // 它會等到 await 完成後才向外 export
};
```

```html
<script type="module">
  console.log('start!');
  import moduleA from './moduleA.js';
  console.log(moduleA);
</script>
```

上面的程式碼會有一個問題，整個程式碼都會被卡住不執行，直到 `moduleA` 的資料被傳回來才會執行。

![](https://i.imgur.com/nVVeXId.gif)

最好的寫法應該是搭配動態 import 來使用：

```html
<script type="module">
  console.log('start!');
  const moduleA = await import('./moduleA.js');
  console.log(moduleA);
</script>
```

![](https://i.imgur.com/iiZlssr.gif)
