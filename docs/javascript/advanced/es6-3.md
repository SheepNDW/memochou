---
outline: deep
---

# ECMAScript 6 學習筆記

> 參考學習資源：[阮一峰 ECMAScript 6 (ES6) 標準入門教程 第三版](https://www.bookstack.cn/books/es6-3rd)、[從 ES6 開始的 JavaScript 學習生活](https://eddy-chang.gitbook.io/javascript-start-from-es6/)

本筆記僅記錄複習 ES6+ 時一些不太熟悉或是比較重要的內容，並非所有的新特性及內容。


## Promise

> Promise 是非同步程式設計的一種解決方案，比傳統的解決方案 callback 更合理和更強大。ES6 將其寫進了語言標準，統一了用法，原生提供了`Promise` 物件。

- 指定 callback 的方式更靈活易懂。
- 解決非同步 **callback hell（回呼地獄）** 的問題。

### 基本用法

Promise 建構函式接收一個函式（executor）作為參數，這個執行器函式又分別接收兩個函式作為參數 `resolve` 和 `reject`。這兩個函式由 JavaScript 引擎提供，不需要自己去寫。

```js
let pro = new Promise((resolve, reject) => {
  // 執行器函式 (executor)
  if (/* 非同步操作成功 */) {
    resolve('success');
  } else {
    reject('fail');
  }
});

// 可以用 then 方法分別指定 resolved 狀態和 rejected 狀態的 callback
pro.then(
  // 成功 callback
  () => {
    console.log('實現');
  },
  // 失敗 callback
  () => {
    console.log('拒絕');
  }
);

// 更常見的寫法是使用 .catch 去處理 rejected 狀態
pro
  .then((res) => {
    console.log('實現', res);
  })
  .catch((err) => {
    console.log('拒絕', err);
  });
```

### Promise 物件的狀態

Promise 物件透過自身的狀態，來控制非同步操作。Promise 實體具有三種狀態：

- 非同步操作未完成（pending）
- 非同步操作成功（fulfilled）
- 非同步操作失敗（rejected）

這三種狀態的變化途徑只有兩種：

- 從"未完成"到"成功"
- 從"未完成"到"失敗"

一旦狀態發生變化，就凝固了，不會再有新的狀態變化。這也是 Promise 這個名字的由來，它的英文意思譯作"承諾"，一旦承諾生效，就不得在改變了。Promise 實體的狀態變化只可能發生一次。

因此，Promise 的最終結果只有兩種：

>非同步操作成功，Promise 實體拋出一個值（value），狀態變為 fulfilled。<br>
>非同步操作失敗，Promise 實體拋出一個錯誤（error），狀態變為 rejected。

![](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/promises.png)

案例：假設有個業務需將第一次請求的回傳值當作參數去發第二次請求

```json
// 1.json
{
  "data": 11111
}

// 2.json
{
  "data": 22222
}
```

```js
function ajax(url) {
  return new Promise((resolve, reject) => {
    let xhr = new XMLHttpRequest();
    xhr.open('get', url, true);
    xhr.send();
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status >= 200 && xhr.status < 300) {
          resolve(JSON.parse(xhr.responseText));
        } else {
          reject(xhr.responseText);
        }
      }
    };
  });
}

ajax('1.json')
  .then((res) => {
    console.log(res);
    return ajax('2.json', res);
  })
  .then((res) => {
    console.log(res);
  })
  .catch((err) => {
    console.log(err);
  });
```

`then` 如果回傳非 Promise 的值，則為 pending-fulfilled，如果回傳 Promise，則根據這個新的 Promise 的結果決定 pending-fulfilled 或 pending-rejected，透過鏈式呼叫 `.then` 可以解決掉過去 callback hell 的問題。

### Promise.all()

`Promise.all()` 方法用於將多個 Promise 實體，包裝成一個新的 Promise 實體。

```js
let pro1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(1000);
  }, 1000);
});
let pro2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(2000);
  }, 2000);
});
let pro3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(3000);
  }, 3000);
});

Promise.all([pro1, pro2, pro3])
  .then((res) => {
    console.log(res); // prints: [1000, 2000, 3000]
  })
  .catch((err) => console.log(err));
```

> 只有 3 個實體的狀態都變成 `fulfilled` 才會回傳一個由 pro1、pro2、pro3 的回傳值組成的陣列，只要其中一個被 `rejected`，Promise.all 的狀態就會變成 `rejected`，此時第一個被 `reject` 的實體的回傳值，會傳遞給 catch 的 callback。

### Promise.race()

`Promise.race()` 方法同樣是將多個 Promise 實體，包裝成一個新的 Promise 實體。

```js
// 接續上方例子

Promise.race([pro1, pro2, pro3])
  .then((res) => {
    console.log(res); // prints: 1000
  })
  .catch((err) => console.log(err));
```

> 只要 pro1、pro2、pro3 之中有一個實體先改變狀態，Promise.race 的狀態就會跟著改變並且最先改變的 Promise 實體回傳值就會傳給 Promise.race 的 callback。

應用場景：請求超時處理

```js
let p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(1000);
  }, 30000);
});
let p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(2000);
  }, 2000);
});

Promise.race([p1, p2])
  .then((res) => {
    console.log(res);
  })
  .catch((err) => console.log(err, '超時了'));
// prints: 2000 '超時了'
```

## Generator

> Generator 函式是 ES6 提供的一種非同步程式設計的解決方案。
> 
> Generator 函式是一個狀態機，封裝了多個內部狀態。

執行 Generator 函式會回傳一個 iterator 物件，也就是說，Generator 函式除了狀態機，還是一個 iterator 物件生成的函式。回傳的 iterator 可以依次遍歷 Generator 函式內部的每一個狀態。

### 基本用法

```js
function* gen() {
  console.log(1);
  yield;
  console.log(2);
  yield;
  console.log(3);
}

let g = gen();

g.next();
g.next();
g.next();

/*
  prints: 1 2 3
*/
```

> yield 表達式是暫停執行的標記，而 next 方法可以恢復執行

### 非同步流程

用 Generator 去改寫 Promise 筆記中發送兩次請求案例：

- 手動驅動版本：

```js
function* gen() {
  let res = yield ajax('1.json');
  console.log('第一次請求的結果', res);
  let res2 = yield ajax('2.json', res);
  console.log('第二次請求的結果', res2);
}

let g = gen();

g.next().value.then((data) => {
  g.next(data).value.then((res) => {
    g.next(res);
  });
});

/*
  第一次請求的結果 {data: 11111}
  第二次請求的結果 {data: 22222}
*/
```

- 自動版本：

```js
function* gen() {
  let res = yield ajax('1.json');
  console.log('第一次請求的結果', res);
  let res2 = yield ajax('2.json', res);
  console.log('第二次請求的結果', res2);
}

function AutoRun(gen) {
  let g = gen();

  function next(data) {
    let res = g.next(data);
    if (res.done) return;
    res.value.then((data) => {
      next(data);
    });
  }

  next();
}

AutoRun(gen);
/*
  第一次請求的結果 {data: 11111}
  第二次請求的結果 {data: 22222}
*/
```
