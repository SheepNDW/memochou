import{_ as l,i as h,o as t,am as n,j as s,y as a}from"./chunks/framework.DuyRO-Y4.js";const C=JSON.parse('{"title":"堆積 Heap","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"ithelp2023/Day15.md","filePath":"ithelp2023/Day15.md","lastUpdated":1696069445000}'),p={name:"ithelp2023/Day15.md"},k={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},e={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"4.618ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 2041 1000","aria-hidden":"true"},r={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},E={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"5.832ex",height:"2.452ex",role:"img",focusable:"false",viewBox:"0 -833.9 2577.6 1083.9","aria-hidden":"true"},d={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},g={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"8.766ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 3874.7 1000","aria-hidden":"true"},y={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},o={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"10.501ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 4641.3 1000","aria-hidden":"true"};function F(Q,i,T,c,m,A){return t(),h("div",null,[i[15]||(i[15]=n("",22)),s("p",null,[i[2]||(i[2]=a("這些公式允許我們在不使用指標的情況下，就可以在陣列中找到節點的父節點和子節點。進行計算時只需要 ",-1)),s("mjx-container",k,[(t(),h("svg",e,[...i[0]||(i[0]=[n("",1)])])),i[1]||(i[1]=s("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")])],-1))]),i[3]||(i[3]=a(" 的時間複雜度。",-1))]),i[16]||(i[16]=n("",6)),s("p",null,[i[6]||(i[6]=a("selection sort 最差的情況下，時間複雜度是 ",-1)),s("mjx-container",r,[(t(),h("svg",E,[...i[4]||(i[4]=[n("",1)])])),i[5]||(i[5]=s("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("msup",null,[s("mi",null,"n"),s("mn",null,"2")]),s("mo",{stretchy:"false"},")")])],-1))]),i[7]||(i[7]=a("，這是因為未排序的部分是沒有規律可言的，每次都要把裡面全部掃一遍。要想提高效率，就要讓未排序部分先轉換成某種規律的形式，藉此來提高尋找的效率。heap sort 就是先把一個無序的系統轉換成 heap，並且每次都把根節點（最小或最大的元素）取出，然後再次保持 heap 的特性。",-1))]),i[17]||(i[17]=n("",20)),s("p",null,[i[12]||(i[12]=a("因為僅保存了 K 個元素，調整 min heap 的時間複雜度是 ",-1)),s("mjx-container",d,[(t(),h("svg",g,[...i[8]||(i[8]=[n("",1)])])),i[9]||(i[9]=s("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"log"),s("mo",{"data-mjx-texclass":"NONE"},"⁡"),s("mi",null,"K"),s("mo",{stretchy:"false"},")")])],-1))]),i[13]||(i[13]=a("，所以整體的時間複雜度是 ",-1)),s("mjx-container",y,[(t(),h("svg",o,[...i[10]||(i[10]=[n("",1)])])),i[11]||(i[11]=s("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mi",null,"log"),s("mo",{"data-mjx-texclass":"NONE"},"⁡"),s("mi",null,"K"),s("mo",{stretchy:"false"},")")])],-1))]),i[14]||(i[14]=a("。",-1))]),i[18]||(i[18]=s("p",null,"今天學到了 heap 結構，明天我們要繼續接著看一種利用 heap 實作的資料結構：優先佇列（Priority Queue）。",-1)),i[19]||(i[19]=s("h2",{id:"參考資料",tabindex:"-1"},[a("參考資料 "),s("a",{class:"header-anchor",href:"#參考資料","aria-label":'Permalink to "參考資料"'},"​")],-1)),i[20]||(i[20]=s("ul",null,[s("li",null,[s("a",{href:"https://www.tenlong.com.tw/products/9787115596154?list_name=r-zh_cn",target:"_blank",rel:"noreferrer"},"《JavaScript 算法：基本原理與代碼實現》")])],-1))])}const u=l(p,[["render",F]]);export{C as __pageData,u as default};
