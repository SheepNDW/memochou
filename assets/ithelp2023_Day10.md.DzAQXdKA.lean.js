import{_ as l,i as n,o as e,am as t,j as i,y as a}from"./chunks/framework.DuyRO-Y4.js";const C=JSON.parse('{"title":"Sequential Search & Binary Search","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"ithelp2023/Day10.md","filePath":"ithelp2023/Day10.md","lastUpdated":1695614335000}'),h={name:"ithelp2023/Day10.md"},p={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},r={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"4.844ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 2141 1000","aria-hidden":"true"},k={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},d={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"8.112ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 3585.7 1000","aria-hidden":"true"},o={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},T={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"8.112ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 3585.7 1000","aria-hidden":"true"},Q={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},g={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"8.112ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 3585.7 1000","aria-hidden":"true"},E={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},m={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"4.844ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 2141 1000","aria-hidden":"true"},y={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},c={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"8.112ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 3585.7 1000","aria-hidden":"true"};function u(x,s,f,F,b,w){return e(),n("div",null,[s[33]||(s[33]=t("",6)),i("p",null,[s[2]||(s[2]=a("我們在尋找過程有可能在第一個元素就找到，也有可能在最後一個元素才找到，或者是根本找不到。在最壞的情況下，我們需要將所有元素都比較一次，因此時間複雜度為 ",-1)),i("mjx-container",p,[(e(),n("svg",r,[...s[0]||(s[0]=[t("",1)])])),s[1]||(s[1]=i("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[i("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[i("mi",null,"O"),i("mo",{stretchy:"false"},"("),i("mi",null,"n"),i("mo",{stretchy:"false"},")")])],-1))]),s[3]||(s[3]=a("，是一種比較低效的搜尋演算法。",-1))]),s[34]||(s[34]=t("",4)),i("p",null,[s[6]||(s[6]=a("循序搜尋適合用在",-1)),s[7]||(s[7]=i("strong",null,"未排序",-1)),s[8]||(s[8]=a("的資料中，但是如果資料已經排序過了，我們就可以使用更快速的搜尋演算法來加速整個搜尋過程，讓複雜度降低到 ",-1)),i("mjx-container",k,[(e(),n("svg",d,[...s[4]||(s[4]=[t("",1)])])),s[5]||(s[5]=i("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[i("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[i("mi",null,"O"),i("mo",{stretchy:"false"},"("),i("mi",null,"log"),i("mo",{"data-mjx-texclass":"NONE"},"⁡"),i("mi",null,"n"),i("mo",{stretchy:"false"},")")])],-1))]),s[9]||(s[9]=a("。而我今天要介紹的就是二分搜尋法（Binary Search）。",-1))]),s[35]||(s[35]=t("",13)),i("p",null,[s[12]||(s[12]=a("給你一個已經排序過的陣列 ",-1)),s[13]||(s[13]=i("code",null,"nums",-1)),s[14]||(s[14]=a(" 和一個目標值 ",-1)),s[15]||(s[15]=i("code",null,"target",-1)),s[16]||(s[16]=a("，如果目標值存在於陣列中，則回傳目標值的索引，如果目標值不存在於陣列中，則回傳目標值應該被插入的位置索引。另外要求你必須在 ",-1)),i("mjx-container",o,[(e(),n("svg",T,[...s[10]||(s[10]=[t("",1)])])),s[11]||(s[11]=i("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[i("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[i("mi",null,"O"),i("mo",{stretchy:"false"},"("),i("mi",null,"log"),i("mo",{"data-mjx-texclass":"NONE"},"⁡"),i("mi",null,"n"),i("mo",{stretchy:"false"},")")])],-1))]),s[17]||(s[17]=a(" 的時間複雜度內完成。",-1))]),s[36]||(s[36]=t("",9)),i("p",null,[s[20]||(s[20]=a("給你一個陣列 ",-1)),s[21]||(s[21]=i("code",null,"nums",-1)),s[22]||(s[22]=a("，你需要找出一個 peak element，peak element 的定義是：陣列中的一個元素，大於左右相鄰的元素。你可以假設 ",-1)),s[23]||(s[23]=i("code",null,"nums[-1] = nums[n] = -∞",-1)),s[24]||(s[24]=a("，也就是說陣列的邊界元素是負無限大，此外陣列中可能存在複數個 peak element。現在要請你寫一個時間複雜度為 ",-1)),i("mjx-container",Q,[(e(),n("svg",g,[...s[18]||(s[18]=[t("",1)])])),s[19]||(s[19]=i("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[i("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[i("mi",null,"O"),i("mo",{stretchy:"false"},"("),i("mi",null,"log"),i("mo",{"data-mjx-texclass":"NONE"},"⁡"),i("mi",null,"n"),i("mo",{stretchy:"false"},")")])],-1))]),s[25]||(s[25]=a(" 的演算法來解決這個問題。",-1))]),s[37]||(s[37]=t("",3)),i("p",null,[s[30]||(s[30]=a("思路：直覺反應一定是直接迴圈把每一個都掃過一次檢查看是不是 peak，但是這樣的複雜度是 ",-1)),i("mjx-container",E,[(e(),n("svg",m,[...s[26]||(s[26]=[t("",1)])])),s[27]||(s[27]=i("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[i("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[i("mi",null,"O"),i("mo",{stretchy:"false"},"("),i("mi",null,"n"),i("mo",{stretchy:"false"},")")])],-1))]),s[31]||(s[31]=a("，題目要求我們必須在 ",-1)),i("mjx-container",y,[(e(),n("svg",c,[...s[28]||(s[28]=[t("",1)])])),s[29]||(s[29]=i("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[i("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[i("mi",null,"O"),i("mo",{stretchy:"false"},"("),i("mi",null,"log"),i("mo",{"data-mjx-texclass":"NONE"},"⁡"),i("mi",null,"n"),i("mo",{stretchy:"false"},")")])],-1))]),s[32]||(s[32]=a(" 的時間複雜度內完成，所以我們要使用 binary search 來解決這個問題。這題和前面的 binary search 稍微不同的地方在於，我們要找的不是一個特定的值，而是一個條件，也就是 peak element，我們可以從中點元素和它的右邊鄰居的大小關係來縮小搜尋範圍：",-1))]),s[38]||(s[38]=t("",8))])}const D=l(h,[["render",u]]);export{C as __pageData,D as default};
